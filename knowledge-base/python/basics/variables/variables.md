---
title: "Переменные"
difficulty: easy
tags: [variables, scope, legb, naming, unpacking, references, types]
added: "2026-02-18"
last_reviewed: null
---

## Что это такое

Переменная в Python — это **имя (метка), привязанное к объекту в памяти**.
В отличие от C или Java, переменная не является ячейкой памяти с фиксированным типом.
Она просто указывает на объект, который уже находится в памяти (heap).

Это означает две важные вещи:

1. **Тип не фиксирован** — одна и та же переменная может указывать сначала на `int`,
   потом на `str`, потом на `list`. Python это разрешает.
2. **Несколько переменных могут указывать на один объект** — если ты написал
   `b = a`, то `b` и `a` — это два имени для одного и того же объекта в памяти.

```python
a = [1, 2, 3]
b = a  # b — НЕ копия, а второй указатель на тот же список
b.append(4)
print(a)  # [1, 2, 3, 4] — изменился, потому что это один объект
```

---

## Динамическая типизация

Python — язык с **динамической** и одновременно **строгой** типизацией.

- **Динамическая** — тип определяется в момент присваивания, не при объявлении переменной.
- **Строгая** — Python не приводит типы автоматически. `"5" + 5` — это `TypeError`, не `"55"`.

```python
x = 42
print(type(x))  # <class 'int'>

x = "hello"
print(type(x))  # <class 'str'>

x = [1, 2, 3]
print(isinstance(x, list))  # True
print(isinstance(x, (list, tuple)))  # True — проверка нескольких типов сразу
```

> Используй `isinstance()` вместо `type(x) == list` — он учитывает наследование.

---

## Правила и соглашения именования

**Синтаксические правила (нарушение = SyntaxError):**
- Только буквы `a–z`, `A–Z`, цифры `0–9` и символ `_`
- Не может начинаться с цифры: `1name` — ошибка, `name1` — ок
- Нельзя использовать ключевые слова: `if`, `for`, `class`, `return`, `None` и др.
- Регистрозависимы: `user`, `User` и `USER` — три разные переменные

**Соглашения PEP 8:**

```python
user_name = "Alice"  # обычные переменные — snake_case
MAX_CONNECTIONS = 100  # константы — UPPER_SNAKE_CASE
_cache = {}  # условно приватная — одно подчёркивание
__slots__ = ["x", "y"]  # зарезервировано Python — двойное подчёркивание
```

**Никогда не затеняй встроенные имена:**

```python
list = [1, 2, 3]  # list больше не встроенный тип!
list([4, 5])  # TypeError: 'list' object is not callable
# Опасно перекрывать: list, dict, set, str, int, type, input, print, id, len
```

---

## Область видимости: правило LEGB

Когда Python встречает имя переменной, он ищет его по цепочке **LEGB**:

| Уровень | Где | Пример |
|---------|-----|--------|
| **L** Local | Текущая функция | `def f(): x = 1` |
| **E** Enclosing | Объемлющая функция | Вложенные функции |
| **G** Global | Уровень модуля | `x = 1` вне функций |
| **B** Built-in | Встроенные имена Python | `len`, `print`, `range` |

```python
x = "global"


def outer():
    x = "enclosing"

    def inner():
        x = "local"
        print(x)  # "local" — нашли на L, дальше не идём

    inner()
    print(x)  # "enclosing"


outer()
print(x)  # "global"
```

---

## global и nonlocal

По умолчанию **любое присваивание внутри функции создаёт локальную переменную**.
Чтобы изменить переменную из внешней области — нужно явно указать это.

**`global`** — доступ к переменной уровня модуля:

```python
count = 0


def increment():
    global count  # без этого строка count += 1 -> UnboundLocalError
    count += 1


increment()
increment()
print(count)  # 2
```

**`nonlocal`** — доступ к переменной объемлющей функции (для замыканий):

```python
def make_counter():
    count = 0

    def tick():
        nonlocal count
        count += 1
        return count

    return tick


counter = make_counter()
print(counter())  # 1
print(counter())  # 2
print(counter())  # 3
```

> Злоупотреблять `global` — плохой стиль. Если нужно накапливать состояние,
> используй замыкания (`nonlocal`) или классы.

---

## Множественное присваивание и распаковка

```python
# Параллельное присваивание
a, b = 10, 20

# Swap без временной переменной — классическая идиома Python
a, b = b, a
print(a, b)  # 20 10

# Несколько переменных — одно значение
x = y = z = 0
```

**Расширенная распаковка с оператором `*`:**

```python
first, *rest = [1, 2, 3, 4, 5]
# first = 1, rest = [2, 3, 4, 5]

*init, last = [1, 2, 3, 4, 5]
# init = [1, 2, 3, 4], last = 5

head, *middle, tail = [1, 2, 3, 4, 5]
# head = 1, middle = [2, 3, 4], tail = 5

only, *empty = [42]
# only = 42, empty = []
```

---

## == vs is: равенство и идентичность

- `==` сравнивает **значения** объектов (вызывает `__eq__`)
- `is` проверяет **идентичность** — один ли объект в памяти

```python
a = [1, 2, 3]
b = [1, 2, 3]  # новый объект с теми же данными
c = a  # тот же объект

print(a == b)  # True  — значения равны
print(a is b)  # False — разные объекты в памяти
print(a is c)  # True  — один и тот же объект

# Нюанс: Python кэширует int от -5 до 256
x = 256
y = 256
print(x is y)  # True  — кэшируется

x = 1000
y = 1000
print(x is y)  # False — не кэшируется
```

> Используй `is` только для сравнения с `None`, `True`, `False`.
> Для всего остального — `==`.

---

## Частые ошибки

**1. UnboundLocalError:**
```python
total = 100


def broken():
    print(total)  # UnboundLocalError!
    # Python видит total = ... ниже и считает total локальной.
    # Но до присваивания она ещё не существует.
    total = 200
```

**2. Ссылочная ловушка — shallow vs deep copy:**
```python
import copy

original = {"name": "Alice", "scores": [10, 20, 30]}
shallow = original.copy()
deep = copy.deepcopy(original)

shallow["scores"].append(99)
print(
    original["scores"]
)  # [10, 20, 30, 99] — shallow не защитил вложенный список!
print(deep["scores"])  # [10, 20, 30]     — deep защитил
```

**3. Затенение встроенных имён (см. раздел про именование)**

---

## Вопросы для самопроверки

- Что такое LEGB и в каком порядке Python ищет имя переменной?
- Почему после `b = a` изменение `b` влияет на `a`, если `a` — список?
- Чем `is` отличается от `==`? Когда правильно использовать каждый?
- Что произойдёт, если написать `x += 1` внутри функции, где `x` определена глобально, но без `global x`?
- Что выведет: `head, *middle, tail = [42, 99]`?
- Почему нельзя называть переменную `list`, `dict` или `print`?
- Чем `a.copy()` отличается от `copy.deepcopy(a)`? Когда важна разница?
